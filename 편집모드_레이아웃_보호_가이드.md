# 편집 모드 레이아웃 보호 가이드

## 문제 상황
편집 모드에서 블로그 콘텐츠의 CSS가 앱의 헤더, 탭 네비게이션, 결과 미리보기 버튼에 영향을 주어 행 높이가 커지는 문제가 발생했습니다.

## 해결 방법

### 1. CSS Containment으로 격리
블로그 편집 영역과 앱 헤더를 CSS Containment로 완전히 격리합니다.

```css
/* 블로그 편집 영역 격리 */
.blog-editor {
  isolation: isolate;
  contain: layout style paint;
  position: relative;
  z-index: 1;
}

/* 앱 헤더 완전 격리 */
header.bg-gradient-to-r {
  contain: layout style paint;
  isolation: isolate;
  position: relative;
  z-index: 9999;
}
```

### 2. scopeHTMLForEditor 함수로 CSS 스코핑
블로그 콘텐츠의 모든 CSS 선택자를 `.blog-editor`로 스코핑하여 앱에 영향을 주지 않도록 합니다.

**핵심 로직:**
- 모든 CSS 규칙 블록을 파싱하여 선택자 앞에 `.blog-editor` 추가
- `@media` 쿼리 내부의 선택자도 스코핑
- `<style scoped>` 속성 추가로 추가 격리

**위치:** `app/dashboard/BlogGenerator.tsx`의 `scopeHTMLForEditor` 함수

### 3. 인라인 스타일로 직접 크기 고정
CSS보다 우선순위가 높은 인라인 스타일을 사용하여 헤더의 크기를 직접 고정합니다.

**헤더 자체:**
```tsx
<header 
  className="bg-gradient-to-r from-[#1e293b] via-[#334155] to-[#1e293b] shadow-xl"
  style={isEditMode ? {
    contain: 'layout style paint',
    isolation: 'isolate',
    position: 'relative',
    zIndex: 9999,
    paddingTop: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0,
    margin: 0,
    height: 'auto',
    minHeight: 'auto',
    maxHeight: 'none',
    lineHeight: 'normal',
    boxSizing: 'border-box'
  } : {}}
>
```

**헤더 내부 컨테이너:**
```tsx
<div 
  className="container mx-auto px-4 py-2 flex justify-between items-center"
  style={isEditMode ? {
    paddingTop: '0.5rem',  // py-2 = 8px
    paddingBottom: '0.5rem',  // py-2 = 8px
    paddingLeft: '1rem',  // px-4 = 16px
    paddingRight: '1rem',  // px-4 = 16px
    margin: '0 auto',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    height: 'auto',
    minHeight: 'auto',
    maxHeight: 'none',
    lineHeight: 'normal',
    boxSizing: 'border-box'
  } : {}}
>
```

**헤더 내부 flex 컨테이너:**
```tsx
<div 
  className="flex items-center gap-4"
  style={isEditMode ? {
    display: 'flex',
    alignItems: 'center',
    gap: '1rem',  // gap-4
    height: 'auto',
    minHeight: 'auto',
    maxHeight: 'none',
    margin: 0,
    padding: 0,
    lineHeight: 'normal',
    boxSizing: 'border-box'
  } : {}}
>
```

**헤더 버튼:**
```tsx
<button
  style={isEditMode ? {
    padding: '0.375rem 0.625rem',  // px-2.5 py-1.5
    fontSize: '0.875rem',  // text-sm
    fontWeight: 600,
    margin: 0,
    height: 'auto',
    minHeight: 'auto',
    maxHeight: 'none',
    lineHeight: 'normal',
    display: 'flex',
    alignItems: 'center',
    gap: '0.375rem',  // gap-1.5
    whiteSpace: 'nowrap',
    boxSizing: 'border-box'
  } : {}}
>
```

### 4. 편집 모드 전용 보호 스타일
편집 모드일 때만 적용되는 보호 스타일을 추가합니다.

**위치:** `app/dashboard/BlogGenerator.tsx`의 `{isEditMode && (<style>...</style>)}` 블록

**주요 보호 스타일:**
- 헤더: 모든 선택자 경로에 대해 크기 고정
- 탭 네비게이션: 컨테이너, 버튼, 아이콘 크기 고정
- 결과 미리보기 버튼 바: 컨테이너, 버튼, 아이콘 크기 고정

## 비편집 모드 원래 크기 (참고)

### 최상위 헤더
- 헤더 자체: `padding: 0`
- 헤더 컨테이너: `px-4 py-2` (padding: 1rem 0.5rem)
- 왼쪽 flex 컨테이너: `gap-4` (gap: 1rem)
- 오른쪽 flex 컨테이너: `gap-3` (gap: 0.75rem)
- h1 (제목): `text-lg` (font-size: 1.125rem)
- p (환영 메시지): `text-xs` (font-size: 0.75rem)
- 버튼: `px-2.5 py-1.5` (padding: 0.375rem 0.625rem), `text-sm` (font-size: 0.875rem)
- 버튼 아이콘: `w-3.5 h-3.5` (width/height: 0.875rem)
- Sparkles 아이콘: `w-5 h-5` (width/height: 1.25rem)
- Sparkles 아이콘 컨테이너: `p-1.5` (padding: 0.375rem)

### 탭 네비게이션
- 컨테이너: `p-1.5` (padding: 0.375rem)
- 버튼: `px-4 py-2` (padding: 0.5rem 1rem), `text-sm` (font-size: 0.875rem)
- 아이콘: `w-4 h-4` (width/height: 1rem)
- gap: `gap-1.5` (gap: 0.375rem)

### 결과 미리보기 버튼 바
- 컨테이너: `px-4 py-2` (padding: 1rem 0.5rem)
- 제목 (h3): `text-base` (font-size: 1rem)
- 버튼: `px-2.5 py-1.5` (padding: 0.375rem 0.625rem), `text-xs` (font-size: 0.75rem)
- 버튼 아이콘: `w-3.5 h-3.5` (width/height: 0.875rem)

## 문제 해결 체크리스트

편집 모드에서 레이아웃이 커지는 문제가 발생하면:

1. ✅ `scopeHTMLForEditor` 함수가 모든 CSS 선택자를 제대로 스코핑하는지 확인
2. ✅ 헤더에 인라인 스타일이 적용되어 있는지 확인
3. ✅ 편집 모드 전용 보호 스타일이 제대로 적용되는지 확인
4. ✅ CSS Containment가 제대로 작동하는지 확인
5. ✅ 블로그 콘텐츠의 CSS가 `.blog-editor`로 제대로 스코핑되었는지 확인

## 주의사항

1. **인라인 스타일 우선순위**: 인라인 스타일은 CSS보다 우선순위가 높으므로, 블로그 콘텐츠의 CSS가 헤더에 영향을 주지 않습니다.

2. **CSS Containment**: `contain: layout style paint`는 해당 요소의 레이아웃, 스타일, 페인트가 자식 요소에만 영향을 주도록 격리합니다.

3. **scopeHTMLForEditor 함수**: 이 함수는 블로그 콘텐츠의 모든 CSS 선택자를 `.blog-editor`로 스코핑하여 앱의 다른 요소에 영향을 주지 않도록 합니다.

4. **편집 모드 전용 스타일**: `{isEditMode && (<style>...</style>)}` 블록은 편집 모드일 때만 적용되므로, 비편집 모드에는 영향을 주지 않습니다.

## 수정 날짜
2025-12-06

## 관련 파일 및 코드 위치

### `app/dashboard/BlogGenerator.tsx`

#### 1. scopeHTMLForEditor 함수 (12-101번 라인)
블로그 콘텐츠의 모든 CSS 선택자를 `.blog-editor`로 스코핑하는 핵심 함수입니다.

**주요 로직:**
- CSS 규칙 블록을 파싱하여 선택자 앞에 `.blog-editor` 추가
- `@media` 쿼리 내부의 선택자도 스코핑
- `<style scoped>` 속성 추가

#### 2. 편집 모드 전용 보호 스타일 (1006-1349번 라인)
```tsx
{isEditMode && (
  <style dangerouslySetInnerHTML={{
    __html: `
      /* 블로그 편집 영역 격리 - CSS Containment */
      .blog-editor {
        isolation: isolate;
        contain: layout style paint;
        position: relative;
        z-index: 1;
      }
      
      /* 앱 헤더 완전 격리 */
      header.bg-gradient-to-r {
        contain: layout style paint !important;
        isolation: isolate !important;
        /* ... */
      }
      
      /* 탭 네비게이션 보호 */
      /* 결과 미리보기 버튼 바 보호 */
    `
  }} />
)}
```

#### 3. 헤더 인라인 스타일 (1352-1460번 라인)
헤더와 모든 내부 요소에 인라인 스타일을 적용하여 크기를 직접 고정합니다.

**헤더 자체:**
```tsx
<header 
  className="bg-gradient-to-r from-[#1e293b] via-[#334155] to-[#1e293b] shadow-xl"
  style={isEditMode ? {
    contain: 'layout style paint',
    isolation: 'isolate',
    position: 'relative',
    zIndex: 9999,
    paddingTop: 0,
    paddingBottom: 0,
    // ... 비편집 모드와 동일한 크기로 고정
  } : {}}
>
```

**헤더 내부 컨테이너:**
```tsx
<div 
  className="container mx-auto px-4 py-2 flex justify-between items-center"
  style={isEditMode ? {
    paddingTop: '0.5rem',  // py-2
    paddingBottom: '0.5rem',  // py-2
    // ... 비편집 모드와 동일한 크기로 고정
  } : {}}
>
```

**헤더 내부 모든 요소:**
- 왼쪽 flex 컨테이너: `gap: '1rem'` (gap-4)
- 오른쪽 flex 컨테이너: `gap: '0.75rem'` (gap-3)
- h1: `fontSize: '1.125rem'` (text-lg)
- p: `fontSize: '0.75rem'` (text-xs)
- button: `padding: '0.375rem 0.625rem'` (px-2.5 py-1.5), `fontSize: '0.875rem'` (text-sm)
- button svg: `width: '0.875rem'` (w-3.5), `height: '0.875rem'` (h-3.5)

## 핵심 원칙

1. **인라인 스타일 우선순위**: 인라인 스타일은 CSS보다 우선순위가 높으므로, 블로그 콘텐츠의 CSS가 헤더에 영향을 주지 않습니다.

2. **CSS Containment**: `contain: layout style paint`는 해당 요소의 레이아웃, 스타일, 페인트가 자식 요소에만 영향을 주도록 격리합니다.

3. **CSS 스코핑**: `scopeHTMLForEditor` 함수는 블로그 콘텐츠의 모든 CSS 선택자를 `.blog-editor`로 스코핑하여 앱의 다른 요소에 영향을 주지 않도록 합니다.

4. **편집 모드 전용**: `{isEditMode && ...}` 블록은 편집 모드일 때만 적용되므로, 비편집 모드에는 영향을 주지 않습니다.

## 문제 발생 시 확인 사항

1. ✅ `scopeHTMLForEditor` 함수가 모든 CSS 선택자를 제대로 스코핑하는지 확인
2. ✅ 헤더에 인라인 스타일이 적용되어 있는지 확인 (1352-1460번 라인)
3. ✅ 편집 모드 전용 보호 스타일이 제대로 적용되는지 확인 (1006-1349번 라인)
4. ✅ CSS Containment가 제대로 작동하는지 확인
5. ✅ 블로그 콘텐츠의 CSS가 `.blog-editor`로 제대로 스코핑되었는지 확인 (브라우저 개발자 도구로 확인)

## 디버깅 팁

브라우저 개발자 도구에서:
1. 편집 모드로 전환
2. 헤더 요소를 선택
3. Computed 스타일에서 `padding`, `margin`, `height`, `line-height` 값 확인
4. 인라인 스타일이 적용되어 있는지 확인
5. 블로그 콘텐츠의 CSS가 헤더에 영향을 주는지 확인 (`.blog-editor`로 스코핑되었는지 확인)

## 수정 이력

- 2025-12-06: 초기 해결 방법 적용
  - CSS Containment로 격리
  - scopeHTMLForEditor 함수로 CSS 스코핑
  - 인라인 스타일로 직접 크기 고정
  - 편집 모드 전용 보호 스타일 추가

